#!/usr/bin/env python
"""
Off-the-shelf PIBOSO tagger

Marco Lui, March 2013
"""

import argparse, sys, os
import csv
import tempfile
import bz2

from cPickle import load

from hydrat.store import Store

# Disable hydrat's progressbar output
import hydrat.common.pb as pb
pb.ENABLED = False

from piboso.tokenize import induce
from piboso.common import Timer

import numpy as np
import scipy.sparse as sp

if __name__ == "__main__":
  # TODO: check temp is cleared
  # TODO: configurable tempdir
  parser = argparse.ArgumentParser()
  parser.add_argument("abstracts", metavar="FILE", help="do PIBOSO tagging for FILE (can specify multiple)", nargs='+')
  parser.add_argument("--model","-m", help="read model from")
  parser.add_argument("--output","-o", type=argparse.FileType('w'), metavar="FILE", default=sys.stdout, help="output to FILE (default stdout)")
  args = parser.parse_args()

  chunk = [ open(a) for a in args.abstracts ]

  handle, store_path = tempfile.mkstemp()
  os.close(handle)

  with bz2.BZ2File(args.model) as model_f, Timer() as t:
    print >>sys.stderr, "unpacking model from:", args.model
    features, spaces, L0_cl, L1_cl = load(model_f)
    print >>sys.stderr, "unpacking took {0:.2f}s".format(t.elapsed)

  # induce all the features for the new documents
  # fallback_path and features should come from the pre-trained model
  induce(chunk, store_path, features, spaces)

  #fallback = Store(args.feat, 'r')
  #store = Store(store_path, 'r', fallback=fallback)
  store = Store(store_path, 'r')

  with Timer() as overall_timer:
    L0_preds = []
    for feat, cl in zip(features, L0_cl):
      fm = store.get_FeatureMap('NewDocuments', feat)
      # We need to trim the fv as the feature space may have grown when we tokenized more documents.
      # Hydrat's design is such that new features are appended to the end of a feature space, so
      # we can safely truncate the feature map.
      train_feat_count = cl.metadata['train_feat_count']
      assert(train_feat_count <= fm.raw.shape[1])
      fv = fm.raw[:,:train_feat_count]
      with Timer() as cl_timer:
        pred = cl(fv)
        print >>sys.stderr, "== L1 feat for {0} took {1:.2f}s ({2:.2f} inst/s) ==".format(feat, cl_timer.elapsed, cl_timer.rate(fv.shape[0]))
      L0_preds.append(pred)

    L0_preds = sp.csr_matrix(np.hstack(L0_preds))

    with Timer() as cl_timer:
      L1_preds = L1_cl(L0_preds)
      print >>sys.stderr, "== L1 classify took {0:.2f}s ({1:.2f} inst/s)==".format(cl_timer.elapsed, cl_timer.rate(L0_preds.shape[0]))
      
    print >>sys.stderr, "== classification took {0:.2f}s ({1:.2f} inst/s)==".format(overall_timer.elapsed, overall_timer.rate(L0_preds.shape[0]))

  cl_space = store.get_Space('ebmcat')
  instance_ids = store.get_Space('NewDocuments')

  writer = csv.writer(args.output)
  for inst_id, cl_id in zip(instance_ids, L1_preds.argmax(axis=1)):
    cl_name = cl_space[cl_id]
    writer.writerow((inst_id, cl_name))
